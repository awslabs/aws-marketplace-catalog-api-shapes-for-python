# coding: utf-8

"""
    Offer_1_0_Appendix

        Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved. 

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.byol_pricing_term import ByolPricingTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.configurable_upfront_pricing_term import ConfigurableUpfrontPricingTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.customer_verification_term import CustomerVerificationTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.fixed_upfront_pricing_term import FixedUpfrontPricingTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.free_trial_pricing_term import FreeTrialPricingTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.legal_term import LegalTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.payment_schedule_term import PaymentScheduleTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.recurring_payment_term import RecurringPaymentTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.renewal_term import RenewalTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.support_term import SupportTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.update_information_change_detail import UpdateInformationChangeDetail
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.update_targeting_change_detail import UpdateTargetingChangeDetail
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.usage_based_pricing_term import UsageBasedPricingTerm
from aws_marketplace_catalog_shapes_offer_1_0_appendix.models.validity_term import ValidityTerm
from typing import Optional, Set
from typing_extensions import Self

class ExportAppendixInput(BaseModel):
    """
    ExportAppendixInput
    """ # noqa: E501
    customer_verification_term: Optional[CustomerVerificationTerm] = Field(default=None, alias="CustomerVerificationTerm")
    legal_term: Optional[LegalTerm] = Field(default=None, alias="LegalTerm")
    payment_schedule_term: Optional[PaymentScheduleTerm] = Field(default=None, alias="PaymentScheduleTerm")
    byol_pricing_term: Optional[ByolPricingTerm] = Field(default=None, alias="ByolPricingTerm")
    free_trial_pricing_term: Optional[FreeTrialPricingTerm] = Field(default=None, alias="FreeTrialPricingTerm")
    usage_based_pricing_term: Optional[UsageBasedPricingTerm] = Field(default=None, alias="UsageBasedPricingTerm")
    configurable_upfront_pricing_term: Optional[ConfigurableUpfrontPricingTerm] = Field(default=None, alias="ConfigurableUpfrontPricingTerm")
    recurring_payment_term: Optional[RecurringPaymentTerm] = Field(default=None, alias="RecurringPaymentTerm")
    fixed_upfront_pricing_term: Optional[FixedUpfrontPricingTerm] = Field(default=None, alias="FixedUpfrontPricingTerm")
    support_term: Optional[SupportTerm] = Field(default=None, alias="SupportTerm")
    renewal_term: Optional[RenewalTerm] = Field(default=None, alias="RenewalTerm")
    validity_term: Optional[ValidityTerm] = Field(default=None, alias="ValidityTerm")
    update_information_change_detail: Optional[UpdateInformationChangeDetail] = Field(default=None, alias="UpdateInformationChangeDetail")
    update_targeting_change_detail: Optional[UpdateTargetingChangeDetail] = Field(default=None, alias="UpdateTargetingChangeDetail")
    __properties: ClassVar[List[str]] = ["CustomerVerificationTerm", "LegalTerm", "PaymentScheduleTerm", "ByolPricingTerm", "FreeTrialPricingTerm", "UsageBasedPricingTerm", "ConfigurableUpfrontPricingTerm", "RecurringPaymentTerm", "FixedUpfrontPricingTerm", "SupportTerm", "RenewalTerm", "ValidityTerm", "UpdateInformationChangeDetail", "UpdateTargetingChangeDetail"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ExportAppendixInput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of customer_verification_term
        if self.customer_verification_term:
            _dict['CustomerVerificationTerm'] = self.customer_verification_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of legal_term
        if self.legal_term:
            _dict['LegalTerm'] = self.legal_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payment_schedule_term
        if self.payment_schedule_term:
            _dict['PaymentScheduleTerm'] = self.payment_schedule_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of byol_pricing_term
        if self.byol_pricing_term:
            _dict['ByolPricingTerm'] = self.byol_pricing_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of free_trial_pricing_term
        if self.free_trial_pricing_term:
            _dict['FreeTrialPricingTerm'] = self.free_trial_pricing_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of usage_based_pricing_term
        if self.usage_based_pricing_term:
            _dict['UsageBasedPricingTerm'] = self.usage_based_pricing_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of configurable_upfront_pricing_term
        if self.configurable_upfront_pricing_term:
            _dict['ConfigurableUpfrontPricingTerm'] = self.configurable_upfront_pricing_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of recurring_payment_term
        if self.recurring_payment_term:
            _dict['RecurringPaymentTerm'] = self.recurring_payment_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fixed_upfront_pricing_term
        if self.fixed_upfront_pricing_term:
            _dict['FixedUpfrontPricingTerm'] = self.fixed_upfront_pricing_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of support_term
        if self.support_term:
            _dict['SupportTerm'] = self.support_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of renewal_term
        if self.renewal_term:
            _dict['RenewalTerm'] = self.renewal_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of validity_term
        if self.validity_term:
            _dict['ValidityTerm'] = self.validity_term.to_dict()
        # override the default output from pydantic by calling `to_dict()` of update_information_change_detail
        if self.update_information_change_detail:
            _dict['UpdateInformationChangeDetail'] = self.update_information_change_detail.to_dict()
        # override the default output from pydantic by calling `to_dict()` of update_targeting_change_detail
        if self.update_targeting_change_detail:
            _dict['UpdateTargetingChangeDetail'] = self.update_targeting_change_detail.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ExportAppendixInput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "CustomerVerificationTerm": CustomerVerificationTerm.from_dict(obj["CustomerVerificationTerm"]) if obj.get("CustomerVerificationTerm") is not None else None,
            "LegalTerm": LegalTerm.from_dict(obj["LegalTerm"]) if obj.get("LegalTerm") is not None else None,
            "PaymentScheduleTerm": PaymentScheduleTerm.from_dict(obj["PaymentScheduleTerm"]) if obj.get("PaymentScheduleTerm") is not None else None,
            "ByolPricingTerm": ByolPricingTerm.from_dict(obj["ByolPricingTerm"]) if obj.get("ByolPricingTerm") is not None else None,
            "FreeTrialPricingTerm": FreeTrialPricingTerm.from_dict(obj["FreeTrialPricingTerm"]) if obj.get("FreeTrialPricingTerm") is not None else None,
            "UsageBasedPricingTerm": UsageBasedPricingTerm.from_dict(obj["UsageBasedPricingTerm"]) if obj.get("UsageBasedPricingTerm") is not None else None,
            "ConfigurableUpfrontPricingTerm": ConfigurableUpfrontPricingTerm.from_dict(obj["ConfigurableUpfrontPricingTerm"]) if obj.get("ConfigurableUpfrontPricingTerm") is not None else None,
            "RecurringPaymentTerm": RecurringPaymentTerm.from_dict(obj["RecurringPaymentTerm"]) if obj.get("RecurringPaymentTerm") is not None else None,
            "FixedUpfrontPricingTerm": FixedUpfrontPricingTerm.from_dict(obj["FixedUpfrontPricingTerm"]) if obj.get("FixedUpfrontPricingTerm") is not None else None,
            "SupportTerm": SupportTerm.from_dict(obj["SupportTerm"]) if obj.get("SupportTerm") is not None else None,
            "RenewalTerm": RenewalTerm.from_dict(obj["RenewalTerm"]) if obj.get("RenewalTerm") is not None else None,
            "ValidityTerm": ValidityTerm.from_dict(obj["ValidityTerm"]) if obj.get("ValidityTerm") is not None else None,
            "UpdateInformationChangeDetail": UpdateInformationChangeDetail.from_dict(obj["UpdateInformationChangeDetail"]) if obj.get("UpdateInformationChangeDetail") is not None else None,
            "UpdateTargetingChangeDetail": UpdateTargetingChangeDetail.from_dict(obj["UpdateTargetingChangeDetail"]) if obj.get("UpdateTargetingChangeDetail") is not None else None
        })
        return _obj


